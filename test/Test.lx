# comment

###
multi-
line
comment
###

import sub.Another;
import sub.Another.helloFromAnotherModule;

using StringTools;

mut globalVariable = "this is global";

@[test](123)
def main:
	# semi-colon test
	trace("Hello Laxe!"); trace("Helo Laxe2");

	# bool
	trace(true);

	#number
	trace(123);
	trace(-432);
	trace(3 - 3 * 2);
	trace(3 - 3 * 2 == -3);

	# string
	trace("Hello World");
	trace('Hello ${123}');

	# variable
	let a = 123;
	trace(a * 2);

	mut b = "Hello";
	b += " World";
	trace(b);

	# block
	block:
		trace("this is inside block");

	trace(block:
		trace("this is also inside block");
		"this will print outside block";
	)

	# if
	if 3 == 3:
		trace("this should print since 3 equals 3");
	
	# else
	if 1 == 2:
		trace("this should not print");
	else if 2 == 3:
		trace("this should also not print");
	else:
		trace("since everything else is false, this will print");

	# else if
	trace(if false:
		"";
	else if true:
		"if statements are still exprs, but be careful with formatting!";
	else:
		""
	)

	# random
	let ifValue = if Math.random() < 0.33: "one";
	elif Math.random() < 0.5: "two";
	else: "three";

	trace('randomly generated: $ifValue');

	# switch
	let s = 123;
	switch s:
		case 1 | 3 | 5:
			trace("1");
		case 123 if false:
			trace("Found 123 from switch!!");
		case _:
			trace("default case on switch");

	# for
	for i in 12...15:
		trace('for: $i');

	# loop
	mut a = "";
	loop:
		a += "a";
		if a.length == 3:
			break;
	trace(a);

	# while
	mut i = 1;
	while i <= 3:
		trace('while: ${i++}');

	# runonce while
	runonce while false:
		trace("Run even in false while");
	
	# pass(?)
	if true:
		pass;
	if false:
		pass
	trace("printing underneath empty if");

	# try catch throw
	try:
		throw "test error";
	catch(e: str):
		trace('printing string error: $e');
	catch:
		trace(e);

	# tuples
	var t: (int, int, int) = (1, 2, 3);
	trace(t);
	trace(t.1);

	# named tuples
	let namedTuple = returnNamedTuple();
	trace(namedTuple.b);

	takeInNormalTuple(namedTuple);

	let anotherNamedTuple: (b: int, c: int) = namedTuple.unnamed();
	trace(anotherNamedTuple.b);

	# another function
	anotherFunction();

	# global variable
	globalVariable += "!!!";
	trace(globalVariable);

	# multi-file
	sub.Another.helloFromLaxe();
	helloFromAnotherModule();

	# call haxe function
	HaxeTest.helloFromHaxe();

	# test arguments and return
	trace(doMath(123, 321));

	# create class
	mut cls = new ClassTest();
	cls.hello();

	# create generic class
	new GenericClass<int>(123);
	new GenericClass(100);
	new GenericClass("Hello from generic class!");

	# metadata
	let rtti = haxe.rtti.Rtti.getRtti(ClassTest);
	trace(rtti.meta);

	# test decor
	trace(@AddThree 0);
	trace(@AddThree 123);
	trace(@Another.AndMore "Dinosaurs");

	# using
	let myStr = "Hello World";
	trace(myStr.replace("Hello", "Goodbye"));

# args and return types
def doMath(a: int, b: int) -> int:
	# return 
	return a + b;

# inline function
def anotherFunction(): trace("calling from another function");

# named tuple
def returnNamedTuple -> (a: int, b: int):
	return (123, 321);

def takeInNormalTuple(t: (int, int)):
	trace(t);

# normal class
@[:rtti]
@[this is meta](1, 2, 3)
@laxe.test(123)
class ClassTest:
	def new: trace("Created ClassTest!");
	def hello -> str: 
		trace("Hello from ClassTest!");
		return "test";

# generic class
class GenericClass<T>:
	def new(value: T):
		trace('The generic value is $value');

# interface
interface Blaable:
	def bla -> void;

class TestImpl implements Blaable:
	def bla: trace("bla");

# decorators
decor AddThree:
	def onExpr(e: expr) -> expr:
		return expr.fromString(e.toString() + " + 3");
